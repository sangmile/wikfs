# 고급 리스트 기능

이 페이지에서 정리할 내용입니다.

* 파이썬 리스트 생성 및 활용
* 리스트 복사 vs 리스트 변수 복사
* 인덱스
* 조각으로부터 데이터 가져오기
* 조각 안에 값 대입하기
* 리스트 연산자
* 얕은 복사 vs 깊은 복사
* 리스트 함수
* 리스트 메서드: 리스트 수정하기
* 리스트 메서드: 내용 정보 가져오기
* 리스트 메서드: 재편성하기
* 스택 역할을 하는 리스트: RPN 애플리케이션
* reduce 함수
* 람다 함수
* 리스트 함축
* 딕셔너리와 세트의 함축
* 리스트를 통한 인수 전달하기
* 다차원 리스트

## 파이썬 리스트 생성 및 활용

파이썬은 데이터를 선언할 필요가 없다. 다른 데이터를 만드는 방법과 동일하게 만들 수 있습니.

* x = \[1, 2, 3\]

리스트 컬렉션의 변수 이름을 정할 때 'list'를 접미사로 사용하는 것이 좋습니다.

숫자와 문자열 데이터를 섞어서 리스트를 생성할 수 있지만 피하는 것이 좋습니다. 파이썬 3.0에서는 데이터 타입이 섞여 있으면 sort 메서드를 사용할 수 없기 때문입니다.

컬렉션을 구축하는 또 다른 방법은 다음과 같이 빈 리스트에 항목을 추가\(append\)하는 것입니다.

```python
my_list = [] # 반드시 빈 리스트를 만들어야 합니다.
my_list.append(1)
my_list.remove(1) # 항목을 삭제할 수도 있습니다.
```

리스트에 없는 값을 삭제하면 ValueError를 발생시킵니다.

리스트 항목의 나열 순서는 중요합니다.

```python
the_scores = [1.0, 1.0, 9.5, 1.0]
the_scores.remove(1.0) # 첫번째 항목 삭제됨. [1.0, 9.5, 1.0]
```

## 리스트 복사 vs 리스트 변수 복사

파이썬의 변수는 C++의 '값'보다는 '참조'에 가깝습니다. 한 컬렉션을 제대로 복사하려면 추가 작업이 필요하다는 의미입니다. 다음의 경우 `b_lst`는 `a_lst`의 별칭이 됩니다. 둘 중 한 변수의 값을 변경하면 다른 하나도 함께 변경됩니다.

```python
a_lst = [1, 2, 3]
b_lst = a_lst
```

리스트 전체 항목을 복사하려면 항목 간 복사를 해야 합니다. 다음은 슬라이싱을 사용한 예입니다.

```python
a_lst = [1, 2, 3]
b_lst = a_lst[:]
```

## 익덱스

파이썬은 0을 포함한 양수와 음수 인덱스를 제공합니다.

### 양수 인덱스

항목의 개수가 N개면 인덱스는 0부터 N-1까지 저장됩니다.

{% hint style="info" %}
print 함수를 반복적으로 호출하는 것은 속도를 저하시킵니다. 빠르게 확인하려면 다음과 같이 print를 한 번만 호출합니다.  
print\(a_lst\[0\], b_list\[1\], c\_lst\[2\], sep='\n'\)
{% endhint %}

### 음수 인덱스

리스트 항목은 리스트 끝에서의 거리를 의미하는 음수 인덱스로 조회할 수도 있습니다.

### enumerate 함수로 인덱스 숫자 생성

코드를 작성할 때 range 함수가 반드시 필요하지 않다면 사용하지 않는 것이 '파이썬스러운\(pythonic\)' 방법입니다.

```python
a_lst = ['A', 'B', 'C']
for s in a_lst:
    print(s)
```

위 방법은 비효율적이고 느린 인덱스를 사용하는 다음 코드보다 더 자연스럽고 효율적입니다.

```python
for i in range(len(a_lst):
    print(a_lst[i])
```

각 항목을 숫자와 함께 출력하고 싶다면 인덱스를 사용해도 되지만 enumerate 함수를 사용하는 것이 좋습니다.

* enumerate\(이터러블, 시작=0\)

이 함수는 리스트와 같은 이터러블을 인수로 받아서 튜플이 나열된 또 다른 이터러블을 생성합니다. 각 튜플은 다음과 같은 모습입니다.

* \(숫자, 항목\)

```python
>>> list(enumerate(a_lst,1))
[(1, 'A'), (2, 'B'), (3, 'C')]
```

for 루프를 사용하여 다음과 같이 나타낼 수 있습니다.

```python
>>> for n, ch in enumerate(a_lst, 1):
...     print(n, '. ', ch, sep='')
...
1. A
2. B
3. C
```

## 조각으로부터 데이터 가져오기

인덱스를 사용하면 한 번에 하나의 항목만 가져올 수 있지만, 슬라이싱 기법을 사용하면 구체적인 범위의 하위 리스트를 만들 수 있습니다.

인수 '스텝'은 양수나 음수일 수 있지만, 0이 될수는 없습니다. '스텝'이 음수면 다른 인수의 기본값은 다음과 같이 변경됩니다.

* 인수 '시작'의 기본값은 리스트의 마지막 항목이 됩니다.
* 인수 '종료'의 기본값은 리스트의 첫 항목이 됩니다.

그러면 \[::-1\]은 기존 리스트를 역순으로 나열한 리스트를 생성합니다.

## 조각 안에 값 대입하기

리스트는 가변 타입이며 항목에 바로 값을 대입할 수 있습니다. 슬라이싱에도 마찬가지입니다.

```python
>>> my_lst = [1, 2, 3, 4, 5, 6]
>>> my_lst[1:4] = [100, 200]
>>> my_lst
[1, 100, 200, 5, 6]
```

\[2, 3, 4\]를 삭제하고 \[100, 200\]을 삽입합니다.

슬라이싱 범위의 길이가 0인 인덱스를 넣을 수도 있습니다. 기존 값을 삭제하지 않고 해당 위치에 새로운 리스트 항목을 삽입합니다.

```python
>>> my_lst[0:0] = [-2, -1]
>>> my_lst
[-2, -1, 1, 100, 200, 5, 6]
```

조각 안에 값을 대입할 때는 다음과 같은 제약 사항이 있습니다.

* 조각 안에 리스트를 대입할 때, 대입하려고 하는 대상은 반드시 다른 리스트나 컬렉션이어야 합니다.
* 조각 안에 리스트를 대입할 때 '스텝'이 명시된다면 조각의 범위와 삽입할 데이터의 길이가 반드시 같아야 합니다.

## 리스트 연산자

다음은 리스트에 적용되는 내장\(build-in\) 연산자를 요약한 것입니다.

| 연산자/문법 | 설명 |
| :--- | :--- |
| 리스트1 + 리스트2 | 이어 붙이기\(concatenation\)가 수행되면서 모든 항목이 포함된 새로운 리스트 생성 |
| 리스트1 \* n 또는 n \* 리스트1 | 리스트1의 항목을 n번 반복한 리스트 생성 |
| 리스트\[n\] | 인덱스 |
| 리스트\[시작:종료:스텝\] | 슬라이싱 |
| 리스트1 = 리스트2 | 리스트1에 리스트2가 참고하고 있는 객체를 대입. 별칭 생성 |
| 리스트1 = 리스트2\[:\] | 리스트1에 리스트2의 항목 간 복사로 생성된 신규 리스트를 대입 |
| 리스트1 == 리스트2 | 각 항목을 비교하여 내용이 같으면 True |
| 리스트1 != 리스트2 | 내용이 같으면 False |
| 항목 in 리스트 | 리스트 내에 '항목'이 존재하면 True |
| 항목 not in 리스트 | 리스트 내에 '항목'이 존재하지 않으면 True |
| 리스트1 &lt; 리스트2 | 항목 간 미만 비교를 수행 |
| 리스트1 &lt;= 리스트2 | 항목 간 이하 비교 수행 |
| 리스트1 &gt; 리스트2 | 항목 간 초과 비교 수행 |
| 리스트2 &gt;= 리스트2 | 항목 간 이상 비교 수행 |
| \*리스트 | 리스트를 '언팩\(unpacked\)'하여 나열한 독립적인 각각의 항목들로 대체 |

+와 \*는 리스트 항목 간 복사본을 만듭니다. 지금까지는 얕은 복사\(shallow copy\)를 사용해도 큰 문제가 없습니다. 하지만 다차원 배열을 다룰 때는 문제가 발생합니다.

## 얕은 복사 vs 깊은 복사

얕은 복사와 깊은 복사의 차이점은 파이썬에서 무척 중요한 주제입니다. 일단 얕은 복사부터 살펴봅시다.

```python
>>> a_lst = [1, 2, [3, 4]]
>>> b_lst = a_lst[:]
>>> b_lst[0] = 0
>>> b_lst[1] = 0
>>> b_lst[2][0] = 0
>>> b_lst[2][1] = 0
>>> a_lst
[1, 2, [0, 0]]
```

b\_lst 값을 변경한 것이 a\_lst에 반영되지 않을 것 같지만 출력이 기대한 것과 다르다.

얕은 복사는 리스트가 품고 있는 리스트는 참조였기 때문에 참조를 복사한 것이다.

깊은 복사는 내부 리스트도 제대로 복사된다.

```python
>>> import copy
>>> a_lst = [1, 2, [3, 4]]
>>> b_lst = copy.deepcopy(a_lst)
>>> b_lst[2][0] = 0
>>> b_lst[2][1] = 0
>>> a_lst
[1, 2, [3, 4]]
```

![&#xC595;&#xC740; &#xBCF5;&#xC0AC;&#xC640; &#xAE4A;&#xC740; &#xBCF5;&#xC0AC;](../../.gitbook/assets/image%20%2819%29.png)

## 리스트 함수

파이썬 기본 함수 중 리스트와 함께 사용할 수 있는 len, max, min, sorted, versed, sum과 같은 유용한 함수가 많다.

이 함수들은 내부 메서드가 아니다. 메서드는 점 기호\(.\)를 사용하여 호출할 수 있다는 것이 중요한 차이점이다.

```python
len(list)         # 컬렉션 길이 반환
max(list)         # 최댓값을 가진 항목 반환
min(list)         # 최솟값을 가진 항목 반환
reversed(list)    # 역순으로 정렬된 이터레이터 반환
sorted(list)      # 정렬된 리스트 생성
sum(list)         # 모든 항목을 더한 값 반환, 항목들은 무조건 숫자이어야 함
```

컬렉션은 리스트, 문자열, 그리고 기타 파이썬 컬렉션 타입을 포함한다. 딕셔너리인 경우에는 키 개수를 반환한다.

len 함수는 리스트와 자주 사용한다.

```python
for i in range(len(a_lst)):
    a_lst[i] *= 2
```

max와 min 함수는 각각 항목 중 가장 큰 항목과 가장 작은 항목을 생성한다. 이 함수들은 리스트에만 사용 가능하며 모든 항목이 서로 비교 가능해야 한다.

sorted와 reversed 함수는 sort와 reverse 메서드와 유사하다. 하지만 메서드는 리스트 값을 바로 변경하는 반면 함수는 새로운 리스트를 생성한다.



